
# Guidelines for Choosing Between UUIDs and Incremental Integers for Database Primary Keys

## Objective: 
To provide clear guidance on when to use UUIDs versus incremental integers as primary keys in database tables, ensuring a balance between security, performance, and scalability.

## Key Considerations
When choosing between UUIDs and incremental integers, the following factors should be evaluated:
1.	Security: Will the ID be exposed externally (e.g., through APIs)?
2.	Performance: Are there strict performance requirements for querying and indexing?
3.	Scalability: Is the system distributed and requires decentralized ID generation?
4.	Readability: Are human-readable IDs required for debugging or external usage?

## Options Overview
### Incremental Integers
• Description: Sequentially incrementing numbers typically generated by the database.
• Size: 4-8 bytes.
• Advantages: 
    - High performance for indexing and querying.
    - Easy to read and debug.
    - Implicit ordering based on insertion time.
• Disadvantages: 
    - Predictable and easily guessable when exposed externally.
    - Can create bottlenecks in distributed systems.
    - Sharding challenges due to sequential nature.
• When to Use: 
    - Internal systems where IDs are not exposed externally.
    - Performance-critical systems with centralized databases.
### UUIDs (Universally Unique Identifiers)
• Description: 128-bit globally unique identifiers, generated independently across systems.
• Size: 16 bytes.
• Advantages: 
    - Unique across systems and databases.
    - Non-predictable, enhancing security for externally exposed APIs.
    - Can be generated without coordination in distributed systems.
• Disadvantages: 
    - Larger size impacts performance and index storage.
    - Difficult to read or debug manually.
    - Can cause index fragmentation if not sequential (e.g., UUID v4).
• When to Use: 
    - Externally facing APIs or systems where ID predictability is a concern.
    - Distributed systems needing decentralized ID generation.
    - Scenarios involving data sharing or merging across multiple systems.

### Recommended Default
• Use incremental integers as the default primary key type for most internal and performance-sensitive systems.
• Switch to UUIDs in the following scenarios: 
    - The primary key will be exposed externally via APIs.
    - The system is distributed, requiring independent ID generation.
    - The data architecture requires merging or synchronization across multiple databases.

## UUID Version Recommendations
• Use UUID v4 for random generation to maximize uniqueness.
• Use UUID v1 or v7 if partial sequential ordering is required to improve index performance in write-heavy systems.

## Hybrid Approach
For systems requiring both security and performance:
1.	Use incremental integers as the primary key for internal use.
2.	Introduce a separate UUID column for external-facing use cases (e.g., API payloads).
3.	Ensure the UUID column is indexed if frequently queried.

## Implementation Guidelines
1.	Define Requirements: Evaluate the use case based on the considerations outlined above.
2.	Database Configuration: 
    - For integers, use AUTO_INCREMENT (MySQL), SERIAL (PostgreSQL), or equivalent.
    - For UUIDs, ensure the database supports efficient UUID storage (e.g., UUID data type in PostgreSQL).
3.	Security Practices: 
    - Avoid exposing incremental IDs in external APIs.
    - Use UUIDs for resources accessible by multiple authenticated users to prevent ID inference.
4.	Indexing: 
    - Optimize UUID indexing by choosing sequential versions (v1/v7) or ensuring efficient index structures.
5.	Testing and Validation: 
    - Validate the ID generation mechanism during development.
    - Monitor database performance and query times in production.

## Examples
When to Use Incremental Integers:
• Internal employee database where IDs are not exposed externally.
• Performance-critical analytics systems.
When to Use UUIDs:
• Public-facing e-commerce APIs exposing order or user identifiers.
• Distributed microservices needing independent ID generation.
Hybrid Example:
• An e-commerce platform: 
    - Use incremental IDs for internal order tracking.
    - Use UUIDs for order identifiers exposed in customer APIs.

## Reference
https://www.postgresql.org/docs/current/datatype-uuid.html - Official PostgreSQL documentation on the UUID data type.
https://www.uuidtools.com/whatois-uuid - A detailed guide on the different UUID versions
https://www.red-gate.com/simple-talk/databases/sql-server/database-administration-sql-server/database-design-a-pointoin-time-architecture/ - Redgate’s best practices for database design.
https://learn.microsoft.com/en-us/sql/relational-databases/security/encryption/sql-server-and-database-encryption-keys-database-engine?view=sql-server-ver16 – Geeks for Geeks guide on primary keys and their importance.
